function checkNameInput(thePlayer, victimName, command, self, spawn)	local victim = getPlayerFromNameSection(victimName)		if victim == nil then		outputChatBox( "Usage: /"..command, thePlayer, unpack( colour.personal ) )		return	elseif victim == false then		outputChatBox( "Too many matches for name '" .. victimName .. "'", thePlayer, unpack( colour.personal ) )		return	elseif self and victim == thePlayer then		outputChatBox( "You can't do that to yourself!", thePlayer, unpack( colour.personal ) )		return	elseif spawn and not getPlayerClassID( otherPlayer ) then		outputChatBox( "That player hasn't spawned yet!", thePlayer, unpack( colour.personal ) )		return	end		return trueendfunction kick( thePlayer, commandName, otherName, ... )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromName( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /kick <person> [<reason>]", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == thePlayer then		return outputChatBox( "You can't kick yourself!", thePlayer, unpack( colour.personal ) )	end		local text = getPlayerName( otherPlayer ) .. " was kicked from the server by " .. getPlayerName( thePlayer )		local reason = table.concat( {...}, " " )	if reason ~= "" then text = text .. " (" .. reason .. ")" end		outputChatBox( text .. ".", root, unpack( colour.global ) )		kickPlayer( otherPlayer, thePlayer, reason ~= "" and reason or nil )endaddCommandHandler( "kick", kick)--[[function ban( thePlayer, victimName, reason )	if not isPlayerOp( thePlayer ) then return end		local victimPlayer = getPlayerFromName( victimName )	if victimPlayer == nil then		return outputChatBox( "Usage: /ban <person> [<reason>]", thePlayer, unpack( colour.personal ) )	elseif victimPlayer == false then		return outputChatBox( "Too many matches for name '" .. victimName .. "'", thePlayer, unpack( colour.personal ) )	elseif victimPlayer == thePlayer then		return outputChatBox( "You can't ban yourself!", thePlayer, unpack( colour.personal ) )	end		victimName = getPlayerName( victimPlayer )	local text = victimName .. " was banned from the server by " .. getPlayerName( thePlayer )	if reason ~= "" then text = text .. " (" .. reason .. ")" end		local result = banPlayer( victimPlayer, true, true, true , thePlayer, reason ~= "" and reason or nil, 172800 ) -- 2 days	if result then 		outputChatBox( text .. ".", root, unpack( colour.global ) )	else 		outputChatBox( "Banning " .. victimName .. " failed.", thePlayer, unpack( colour.personal ) )	endendaddCommandHandler( "ban", function(player,command,name,... )	local reason = table.concat( {...}, " " )	ban(player,name,reason)end)]]function unbanCommand( thePlayer, commandName, theString )	if not isPlayerOp( thePlayer ) then return end		if not theString then		return outputChatBox( "Usage: /unban <name>", thePlayer, unpack( colour.personal ) )	end		local result		for _,ban in ipairs(getBans()) do		if ban and getBanNick(ban) and getBanNick(ban) == theString then			local ip = getBanIP(ban)			local res = removeBan(ban, thePlayer)			if res then				if not result then result = true end								for _, p in ipairs( getElementsByType( "player" ) ) do					if p and isElement( p ) and isPlayerOp( p ) then						outputChatBox( theString .. " (" .. tostring(ip) .. ") was unbanned from the server by " .. getPlayerName( thePlayer ) .. ".", p, unpack( colour.personal ) )					end				end			end		end	end		if not result then		outputChatBox( "No bans found on " .. theString, thePlayer, unpack( colour.personal ) )	endendaddCommandHandler( "unban", unbanCommand )function setInterior( thePlayer, commandName, otherName, interior )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /setint <person> <interior id>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif not getPlayerClassID( otherPlayer ) then		return outputChatBox( "The other player hasn't spawned.", thePlayer, unpack( colour.personal ) )	elseif not tonumber( interior ) then		return outputChatBox( "Use number for the interior id.", thePlayer, unpack( colour.personal ) )	end		outputChatBox( getPlayerName( otherPlayer ) .. " set to interior " .. interior, thePlayer, unpack( colour.personal ) )	setElementInterior( otherPlayer, tonumber( interior ) )endaddCommandHandler( "setinterior", setInterior )addCommandHandler( "setint", setInterior )function getInterior( thePlayer, commandName, otherName )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /getint(erior) <person>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	end		outputChatBox( getPlayerName( otherPlayer ) .. " is in interior " .. tostring(getElementInterior( otherPlayer )), thePlayer, unpack( colour.personal ) )endaddCommandHandler( "getinterior", getInterior )addCommandHandler( "getint", getInterior )function changeWeatherCommand( thePlayer )	if not isPlayerOp( thePlayer ) then return end		changeWeather()endaddCommandHandler( "changeweather", changeWeatherCommand )-- compcheckfunction thaw( thePlayer, commandName, otherName )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /thaw <person>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	end		local freezeTimer = getElementData( otherPlayer, "ptpm.freezeTimer" )	if freezeTimer then		if isTimer( freezeTimer ) then			killTimer( freezeTimer )		end	end	setElementData( otherPlayer, "ptpm.freezeTimer", nil, false )	setPlayerFrozen( otherPlayer, false )	sendGameText( otherPlayer, "You were thawed by an admin.", 6000, sampTextdrawColours.g, nil, 1.2 )	outputChatBox( getPlayerName( otherPlayer ) .. " thawed.", thePlayer, unpack( colour.personal ) )endaddCommandHandler( "thaw", thaw )-- compcheckfunction freeze( thePlayer, commandName, otherName, howLong )	if not isPlayerOp( thePlayer ) then return end	local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /freeze <person> [<length in seconds>]", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif howLong and tonumber( howLong ) == nil then		return outputChatBox( "Use number for the freeze length.", thePlayer, unpack( colour.personal ) )	elseif howLong and tonumber( howLong ) < 0 then		return outputChatBox( "Invalid freeze length.", thePlayer, unpack( colour.personal ) )	end	otherName = getPlayerName( otherPlayer )	local duration = tonumber( howLong ) or 0	if duration > 0 then		local freezeTimer = getElementData( otherPlayer, "ptpm.freezeTimer" )		if freezeTimer then			if isTimer( freezeTimer ) then				killTimer( freezeTimer )			end		end				freezeTimer = setTimer(			function( victim )				if victim and isElement( victim ) then					sendGameText( victim, "You have been thawed.", 6000, sampTextdrawColours.g, nil, 1.2, nil, nil, 2 )					setPlayerFrozen( victim, false )										setElementData( victim, "ptpm.freezeTimer", nil, false )				end			end,		duration * 1000, 1, otherPlayer )			setElementData( otherPlayer, "ptpm.freezeTimer", freezeTimer, false )			sendGameText( otherPlayer, "You were frozen by an admin for " .. duration .. " seconds.", 6000, sampTextdrawColours.g, nil, 1.2 )		outputChatBox( otherName .. " frozen for ".. duration .. " seconds.", thePlayer, unpack( colour.personal ) )	else		sendGameText( otherPlayer, "You were frozen by an admin.", 6000, sampTextdrawColours.g, "pricedown", 1.2 )		outputChatBox( otherName .. " frozen.", thePlayer, unpack( colour.personal ) )	end	setPlayerFrozen( otherPlayer, true )endaddCommandHandler( "freeze", freeze )function pwarp( thePlayer, commandName, otherName )	if not isPlayerOp( thePlayer ) then return end		if not getPlayerClassID( thePlayer ) then		return outputChatBox( "Spawn first.", thePlayer, unpack( colour.personal ) )	end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /pwarp <person>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif not getPlayerClassID( otherPlayer ) then		return outputChatBox( "The other player hasn't spawned.", thePlayer, unpack( colour.personal ) )	end		local x, y, z = getElementPosition( otherPlayer )	setElementPosition( thePlayer, x, y, z )	outputChatBox( "Done.", thePlayer, unpack( colour.personal ) )endaddCommandHandler( "pwarp", pwarp )function pwarpToMe( thePlayer, commandName, otherName )	if not isPlayerOp( thePlayer ) then return end		if not getPlayerClassID( thePlayer ) then		return outputChatBox( "Spawn first.", thePlayer, unpack( colour.personal ) )	end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /pwarptome <person>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif not getPlayerClassID( otherPlayer ) then		return outputChatBox( "The other player hasn't spawned.", thePlayer, unpack( colour.personal ) )	end		local x, y, z = getElementPosition( thePlayer )	setElementPosition( otherPlayer, x, y, z )	outputChatBox( "Done.", thePlayer, unpack( colour.personal ) )endaddCommandHandler( "pwarptome", pwarpToMe )-- compcheckfunction watch( thePlayer, commandName, otherName )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /watch <person>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == thePlayer then		return outputChatBox( "You may not watch yourself.", thePlayer, unpack( colour.personal ) )	elseif not getPlayerClassID( otherPlayer ) then		return outputChatBox( "Player not yet selected class.", thePlayer, unpack( colour.personal ) )	elseif not getPlayerClassID( thePlayer ) then		return outputChatBox( "You must spawn before watching someone.", thePlayer, unpack( colour.personal ) )	else		local watching = getElementData( otherPlayer, "ptpm.watching" )		if watching then			return outputChatBox( "Player currently watching someone else.", thePlayer, unpack( colour.personal ) )		end	end		setPlayerControllable( thePlayer, false )	exports.spectator:spectateStart( thePlayer, otherPlayer, true )		setElementData( thePlayer, "ptpm.watching", otherPlayer, false )	--playerInfo[thePlayer].watching = otherPlayerendaddCommandHandler( "watch", watch )addCommandHandler( "spec", watch)-- compcheckfunction unwatch( thePlayer, commandName )	if not isPlayerOp( thePlayer ) then return end		local watching = getElementData( thePlayer, "ptpm.watching" )	if not watching then		return outputChatBox( "Not watching anyone.", thePlayer, unpack( colour.personal ) )	end		setPlayerControllable( thePlayer, true )	exports.spectator:spectateStop(thePlayer)	setElementData( thePlayer, "ptpm.watching", nil, false )	--playerInfo[thePlayer].watching = nilendaddCommandHandler( "unwatch", unwatch)addCommandHandler( "unspec", unwatch)function getHealth( thePlayer, commandName, otherName )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /gethealth <person>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif not getPlayerClassID( otherPlayer ) then		return outputChatBox( "Player has not yet selected class.", thePlayer, unpack( colour.personal ) )	end	outputChatBox( getPlayerName( otherPlayer ) .. "'s health: " .. getElementHealth( otherPlayer ), thePlayer, unpack( colour.personal ) )endaddCommandHandler( "gethealth", getHealth )function setHealth( thePlayer, commandName, otherName, newHealth )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil or not newHealth then		return outputChatBox( "Usage: /sethealth <person> <amount>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif not getPlayerClassID( otherPlayer ) then		return outputChatBox( "Player has not yet selected class.", thePlayer, unpack( colour.personal ) )	elseif tonumber( newHealth ) == nil then		return outputChatBox( "Use number for the new health amount.", thePlayer, unpack( colour.personal ) )	elseif tonumber( newHealth ) < 0 or tonumber( newHealth ) > 100 then		return outputChatBox( "Invalid health.", thePlayer, unpack( colour.personal ) )	end	setElementHealth( otherPlayer, newHealth )	outputChatBox( getPlayerName( otherPlayer ) .. "'s health set to: " .. newHealth, thePlayer, unpack( colour.personal ) )endaddCommandHandler( "sethealth", setHealth )function disp( thePlayer, commandName, otherName, dX, dY, dZ )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil or not dX then		return outputChatBox( "Usage: /disp <person> <x> <y> <z>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif not getPlayerClassID( otherPlayer ) then		return outputChatBox( "Player has not yet selected class.", thePlayer, unpack( colour.personal ) )	elseif tonumber( dX ) == nil or (dY and tonumber( dY ) == nil) or (dZ and tonumber( dZ ) == nil) then		return outputChatBox( "Use numbers for coordinates.", thePlayer, unpack( colour.personal ) )	end		dX = tonumber( dX ) or 0	dY = tonumber( dY ) or 0	dZ = tonumber( dZ ) or 0	local pX, pY, pZ = getElementPosition( otherPlayer )	setElementPosition( otherPlayer, pX+dX, pY+dY, pZ+dZ )	outputChatBox( "Warped" .. getPlayerName( otherPlayer ) .. " by (" .. dX .. "," .. dY .. "," .. dZ .. ") to (" .. pX+dX .. "," .. pY+dY .. "," .. pZ+dZ .. ")", thePlayer, unpack( colour.personal ) )endaddCommandHandler( "disp", disp )function spp( thePlayer, commandName, otherName, x, y, z )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil or not x or not y or not z then		return outputChatBox( "Usage: /spp <person> <x> <y> <z>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif not getPlayerClassID( otherPlayer ) then		return outputChatBox( "Player has not yet selected class.", thePlayer, unpack( colour.personal ) )	elseif tonumber( x ) == nil or tonumber( y ) == nil or tonumber( z ) == nil then		return outputChatBox( "Use numbers for coordinates.", thePlayer, unpack( colour.personal ) )	end		x = tonumber( x )	y = tonumber( y )	z = tonumber( z )		setElementPosition( otherPlayer, x, y, z )	outputChatBox( getPlayerName( otherPlayer ) .. " warped to (" .. x .. "," .. y .. "," .. z .. ")", thePlayer, unpack( colour.personal ) )endaddCommandHandler( "spp", spp )function adminSay( thePlayer, commandName, ... )	if not isPlayerOp( thePlayer ) then return end	local text = table.concat( {...}, " " )	if text == "" then		return outputChatBox( "Usage: /adminsay <message>", thePlayer, unpack( colour.personal ) )	end		outputChatBox( "* Admin: " .. text, root, unpack( colour.ptpm ) )endaddCommandHandler( "adminsay", adminSay )function tell( thePlayer, commandName, ... )	if not isPlayerOp( thePlayer ) then return end	local text = table.concat( {...}, " " )	if text == "" then		return outputChatBox( "Usage: /tell <message>", thePlayer, unpack( colour.personal ) )	end		sendGameText( root, text, 4000, sampTextdrawColours.g, nil, 1.5 )endaddCommandHandler( "tell", tell )function disarm( thePlayer, commandName, otherName )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /disarm <person>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif not getPlayerClassID( otherPlayer ) then		return outputChatBox( "Player has not yet selected class.", thePlayer, unpack( colour.personal ) )	end		takeAllWeapons( otherPlayer )		sendGameText( otherPlayer, "Your weapons have been removed by an admin.", 6000, sampTextdrawColours.g, nil, 1.5 )	outputChatBox( getPlayerName( otherPlayer ) .. " disarmed.", thePlayer, unpack( colour.personal ) )endaddCommandHandler( "disarm", disarm )-- compcheckfunction mute( thePlayer, commandName, otherName, howLong )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /mute <person> [<length in seconds>]", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	elseif howLong and tonumber( howLong ) == nil then		return outputChatBox( "Use number for the mute length.", thePlayer, unpack( colour.personal ) )	elseif howLong and tonumber( howLong ) < 0 then		return outputChatBox( "Invalid mute length.", thePlayer, unpack( colour.personal ) )	end		otherName = getPlayerName( otherPlayer )	local duration = tonumber( howLong ) or 0		-- local muted = isPlayerMuted( otherPlayer )	-- if not muted then -- Could cause problems if database was ever to fail		if duration > 0 then			muteTimer = getElementData( otherPlayer, "ptpm.muteTimer" )			if muteTimer then				if isTimer( muteTimer ) then					killTimer( muteTimer )				end			end					muteTimer = setTimer(				function( victim )					if victim and isElement( victim ) then						sendGameText( victim, "You have been unmuted.", 6000, sampTextdrawColours.g, nil, 1.2, nil, nil, 2 )												setPlayerMuted( victim, false )						setElementData( victim, "ptpm.muteTimer", nil, false )						--playerInfo[victim].muted = nil						--playerInfo[victim].mutedTimer = nil					end				end,			duration * 1000, 1, otherPlayer )			setElementData( otherPlayer, "ptpm.muteTimer", muteTimer, false )						sendGameText( otherPlayer, "You have been muted by an admin for " .. duration .. " seconds.", 6000, sampTextdrawColours.g, nil, 1.2 )			outputChatBox( otherName .. " successfully muted for ".. duration .. " seconds.", thePlayer, unpack( colour.personal ) )		else			sendGameText( otherPlayer, "You have been muted by an admin.", 6000, sampTextdrawColours.g, nil, 1.2 )			outputChatBox( otherName .. " successfully muted.", thePlayer, unpack( colour.personal ) )		end		setPlayerMuted( otherPlayer, true )		--playerInfo[otherPlayer].muted = true	-- else		-- outputChatBox( otherName .. " is already muted.", thePlayer, unpack( colour.personal ) )	-- endendaddCommandHandler( "mute", mute )-- compcheckfunction unmute( thePlayer, commandName, otherName )	if not isPlayerOp( thePlayer ) then return end		local otherPlayer = getPlayerFromNameSection( otherName )	if otherPlayer == nil then		return outputChatBox( "Usage: /unmute <person>", thePlayer, unpack( colour.personal ) )	elseif otherPlayer == false then		return outputChatBox( "Too many matches for name '" .. otherName .. "'", thePlayer, unpack( colour.personal ) )	-- else		-- local muted = isPlayerMuted( otherPlayer )		-- if not muted then			-- return outputChatBox( "Other player isn't muted.", thePlayer, unpack( colour.personal ) )		-- end	end		local muteTimer = getElementData( otherPlayer, "ptpm.muteTimer" )	if muteTimer then		if isTimer( muteTimer ) then			killTimer( muteTimer )		end	end		setPlayerMuted( otherPlayer, false )	--playerInfo[otherPlayer].muted = nil		setElementData( otherPlayer, "ptpm.muteTimer", nil, false )	--playerInfo[otherPlayer].muteTimer = nil		sendGameText( otherPlayer, "You have been unmuted by an admin.", 6000, sampTextdrawColours.g, nil, 1.2 )	outputChatBox( getPlayerName( otherPlayer ) .. " successfully unmuted.", thePlayer, unpack( colour.personal ) )endaddCommandHandler( "unmute", unmute )function toggleBoundaries(player)	if not isPlayerOp( player ) then return end		if options then		options.boundariesEnabled = not options.boundariesEnabled		outputChatBox( "Boundaries set to " .. tostring( options.boundariesEnabled ), player, unpack( colour.personal ) )	endendaddCommandHandler( "toggleboundaries", toggleBoundaries )function endRound( thePlayer )	if not isPlayerOp( thePlayer ) then return end	data.roundEnded = true	endGame()		outputChatBox( "Map ended by " .. getPlayerName( thePlayer ) .. ".", root, unpack( colour.global ) )endaddCommandHandler( "endgame", endRound )